import datetime
import logging

from django.contrib import admin, messages
from django.core.exceptions import ValidationError
from django.db.models import BooleanField, Count, ExpressionWrapper, Q
from django.forms import Form, ModelForm, Textarea
from django.forms.models import BaseInlineFormSet
from django.http import HttpResponseRedirect, StreamingHttpResponse
from django.template.defaultfilters import filesizeformat
from django.template.response import TemplateResponse
from django.urls import path, reverse
from django.utils.html import format_html, format_html_join
from django.utils.translation import gettext_lazy as _, ngettext

from privates.storages import PrivateMediaFileSystemStorage
from solo.admin import SingletonModelAdmin

from open_inwoner.ckeditor5.widgets import CKEditorWidget
from open_inwoner.openzaak.import_export import CatalogusConfigImport, ZGWConfigExport
from open_inwoner.utils.forms import LimitedUploadFileField

from .models import (
    CatalogusConfig,
    OpenZaakConfig,
    UserCaseInfoObjectNotification,
    UserCaseStatusNotification,
    ZaakTypeConfig,
    ZaakTypeInformatieObjectTypeConfig,
    ZaakTypeResultaatTypeConfig,
    ZaakTypeStatusTypeConfig,
    ZGWApiGroupConfig,
)

logger = logging.getLogger(__name__)


class ZGWApiGroupConfig(admin.StackedInline):
    model = ZGWApiGroupConfig
    extra = 0


@admin.register(OpenZaakConfig)
class OpenZaakConfigAdmin(SingletonModelAdmin):
    inlines = [ZGWApiGroupConfig]

    fieldsets = (
        (
            "Advanced options",
            {
                "classes": ("collapse",),
                "fields": [
                    "zaak_max_confidentiality",
                    "document_max_confidentiality",
                    "action_required_deadline_days",
                    "max_upload_size",
                    "allowed_file_extensions",
                    "title_text",
                ],
            },
        ),
        (
            "Feature flags",
            {
                "classes": ("collapse",),
                "fields": (
                    "enable_categories_filtering_with_zaken",
                    "zaken_filter_enabled",
                    "use_zaak_omschrijving_as_title",
                    "order_statuses_by_date_set",
                ),
            },
        ),
        (
            _("API behaviour override options"),
            {
                "fields": [
                    "skip_notification_statustype_informeren",
                    "reformat_esuite_zaak_identificatie",
                    "fetch_eherkenning_zaken_with_rsin",
                ],
            },
        ),
    )


class ImportZGWExportFileForm(Form):
    MAX_UPLOAD_SIZE = 1024**2 * 25  # 25MB
    zgw_export_file = LimitedUploadFileField(
        label=_("ZGW export bestand"),
        help_text=_(
            "Upload a file generated by the export function on the 'Catalogus Config' administration page. The maximum size of this file is %(file_size)s"
            % {"file_size": filesizeformat(MAX_UPLOAD_SIZE)}
        ),
        allow_empty_file=False,
        required=True,
        max_upload_size=MAX_UPLOAD_SIZE,
        min_upload_size=1,
        allowed_mime_types=["application/json", "text/plain"],
    )


@admin.register(CatalogusConfig)
class CatalogusConfigAdmin(admin.ModelAdmin):
    change_list_template = "admin/catalogusconfig_change_list.html"

    list_display = [
        "domein",
        "rsin",
        "url",
        "service",
    ]
    fields = [
        "url",
        "domein",
        "rsin",
        "service",
    ]
    readonly_fields = fields
    search_fields = [
        "domein",
        "rsin",
        "url",
    ]
    ordering = ("domein", "rsin")
    list_filter = ("service",)

    actions = ["export_catalogus_configs"]

    def get_urls(self):
        urls = super().get_urls()
        custom_urls = [
            path(
                "import-catalogus-dump/",
                self.admin_site.admin_view(self.process_file_view),
                name="upload_zgw_import_file",
            ),
        ]
        return custom_urls + urls

    @admin.action(description=_("Export to file"))
    def export_catalogus_configs(modeladmin, request, queryset):
        export = ZGWConfigExport.from_catalogus_configs(queryset)
        response = StreamingHttpResponse(
            export.as_jsonl_iter(),
            content_type="application/json",
        )
        response[
            "Content-Disposition"
        ] = 'attachment; filename="zgw-catalogi-export.json"'
        return response

    def process_file_view(self, request):
        form = ImportZGWExportFileForm()

        if request.method == "POST":
            form = ImportZGWExportFileForm(request.POST, request.FILES)
            if form.is_valid():
                storage = PrivateMediaFileSystemStorage()
                timestamp = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
                target_file_name = f"zgw_import_dump_{timestamp}.json"
                storage.save(target_file_name, request.FILES["zgw_export_file"])

                try:
                    import_result = (
                        CatalogusConfigImport.import_from_jsonl_file_in_django_storage(
                            target_file_name,
                            storage,
                        )
                    )
                    self.message_user(
                        request,
                        _(
                            "%(num_rows)d item(s) processed in total, with %(error_rows)d failing row(s)."
                            % {
                                "num_rows": import_result.total_rows_processed,
                                "error_rows": len(import_result.import_errors),
                            }
                        ),
                        messages.SUCCESS
                        if not import_result.import_errors
                        else messages.WARNING,
                    )
                    if errors := import_result.import_errors:
                        msgs_deduped = set(error.__str__() for error in errors)
                        error_msg_iterator = ([msg] for msg in msgs_deduped)

                        error_msg_html = format_html_join(
                            "\n", "<p> - {}</p>", error_msg_iterator
                        )
                        error_msg_html = format_html(
                            _("It was not possible to import the following items:")
                            + f"<div>{error_msg_html}</div>"
                        )
                        self.message_user(request, error_msg_html, messages.ERROR)

                    return HttpResponseRedirect(
                        reverse(
                            "admin:openzaak_catalogusconfig_changelist",
                        )
                    )
                except Exception:
                    logger.exception("Unable to process ZGW import")
                    self.message_user(
                        request,
                        _(
                            "We were unable to process your upload. Please regenerate the file and try again."
                        ),
                        messages.ERROR,
                    )
                finally:
                    storage.delete(target_file_name)

        return TemplateResponse(
            request, "admin/import_zgw_export_form.html", {"form": form}
        )


class HasDocNotifyListFilter(admin.SimpleListFilter):
    title = _("notify document attachment")
    parameter_name = "doc_notify"

    def lookups(self, request, model_admin):
        return [
            ("yes", _("Yes")),
            ("no", _("No")),
        ]

    def queryset(self, request, queryset):
        v = self.value()
        if v == "yes":
            queryset = queryset.filter(has_doc_notify=True)
        elif v == "no":
            queryset = queryset.filter(has_doc_notify=False)
        return queryset


class CatalogUsedListFilter(admin.SimpleListFilter):
    title = _("Catalogus")
    parameter_name = "catalogus"

    def lookups(self, request, model_admin):
        qs = model_admin.get_queryset(request)
        catalogs = CatalogusConfig.objects.filter(
            id__in=qs.values_list("catalogus_id", flat=True).distinct()
        )
        return [(c.id, str(c)) for c in catalogs]

    def queryset(self, request, queryset):
        v = self.value()
        if v:
            if v == "none":
                v = None
            queryset = queryset.filter(catalogus=v)
        return queryset


class ZaakTypeInformatieObjectTypeConfigFormset(BaseInlineFormSet):
    def clean(self):
        instance_doc_upload = self.instance.document_upload_enabled

        for form in self.forms:
            inline_doc_upload = form.cleaned_data["document_upload_enabled"]
            if instance_doc_upload and inline_doc_upload:
                raise ValidationError(
                    _(
                        "Enabling both zaaktype and zaaktypeinformatieobject upload is not allowed. Only one of them should be enabled."
                    )
                )


class ZaakTypeInformatieObjectTypeConfigInline(admin.TabularInline):
    formset = ZaakTypeInformatieObjectTypeConfigFormset
    model = ZaakTypeInformatieObjectTypeConfig
    fields = [
        "omschrijving",
        "document_upload_enabled",
        "document_notification_enabled",
        "informatieobjecttype_uuid",
        "zaaktype_uuids",
    ]
    readonly_fields = [
        "omschrijving",
        "informatieobjecttype_url",
        "informatieobjecttype_uuid",
        "zaaktype_uuids",
    ]
    ordering = ("omschrijving",)

    def has_add_permission(self, request, obj):
        return False

    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser


class ZaakTypeStatusTypeConfigInlineAdminForm(ModelForm):
    class Meta:
        model = ZaakTypeStatusTypeConfig
        fields = "__all__"
        widgets = {
            "document_upload_description": CKEditorWidget,
            "status_indicator_text": Textarea(attrs={"cols": 40, "rows": 10}),
            "description": CKEditorWidget,
        }


class ZaakTypeStatusTypeConfigInline(admin.StackedInline):
    model = ZaakTypeStatusTypeConfig
    classes = ["collapse"]
    fields = [
        "statustekst",
        "omschrijving",
        "statustype_url",
        "zaaktype_uuids",
        "status_indicator",
        "status_indicator_text",
        "notify_status_change",
        "action_required",
        "document_upload_enabled",
        "document_upload_description",
        "description",
        "call_to_action_url",
        "call_to_action_text",
        "case_link_text",
    ]
    readonly_fields = [
        "statustekst",
        "omschrijving",
        "statustype_url",
        "zaaktype_uuids",
    ]
    ordering = (
        "zaaktype_uuids",
        "omschrijving",
    )
    form = ZaakTypeStatusTypeConfigInlineAdminForm

    def has_add_permission(self, request, obj):
        return False

    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser


class ZaakTypeResultaattypeConfigInline(admin.StackedInline):
    model = ZaakTypeResultaatTypeConfig
    classes = ["collapse"]
    fields = [
        "omschrijving",
        "resultaattype_url",
        "zaaktype_uuids",
        "description",
    ]
    readonly_fields = [
        "omschrijving",
        "resultaattype_url",
        "zaaktype_uuids",
    ]
    ordering = (
        "zaaktype_uuids",
        "omschrijving",
    )

    def has_add_permission(self, request, obj):
        return False

    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser


@admin.register(ZaakTypeConfig)
class ZaakTypeConfigAdmin(admin.ModelAdmin):
    inlines = [
        ZaakTypeInformatieObjectTypeConfigInline,
        ZaakTypeStatusTypeConfigInline,
        ZaakTypeResultaattypeConfigInline,
    ]
    actions = [
        "mark_as_notify_status_changes",
        "mark_as_not_notify_status_changes",
        "export_zaaktype_configs",
    ]
    fields = [
        "urls",
        "catalogus",
        "identificatie",
        "omschrijving",
        "contact_form_enabled",
        "contact_subject_code",
        "notify_status_changes",
        "document_upload_enabled",
        "external_document_upload_url",
        "description",
        "relevante_zaakperiode",
    ]
    readonly_fields = [
        "urls",
        "catalogus",
        "identificatie",
        "omschrijving",
        "num_infotypes",
        "num_statustypes",
        "num_resulttypes",
    ]
    list_display = [
        "identificatie",
        "omschrijving",
        "catalogus",
        "notify_status_changes",
        "has_doc_notify",
        "contact_form_enabled",
        "contact_subject_code",
        "document_upload_enabled",
        "num_infotypes",
        "num_statustypes",
        "num_resulttypes",
    ]
    list_display_links = [
        "identificatie",
        "omschrijving",
    ]
    list_filter = [
        "notify_status_changes",
        HasDocNotifyListFilter,
        CatalogUsedListFilter,
    ]
    search_fields = [
        "identificatie",
        "omschrijving",
        "catalogus__domein",
        "catalogus__rsin",
        "contact_subject_code",
    ]
    ordering = ("identificatie", "catalogus__domein")

    @admin.action(description=_("Export to file"))
    def export_zaaktype_configs(modeladmin, request, queryset):
        export = ZGWConfigExport.from_zaaktype_configs(queryset)
        response = StreamingHttpResponse(
            export.as_jsonl_iter(),
            content_type="application/json",
        )
        response[
            "Content-Disposition"
        ] = 'attachment; filename="zgw-zaaktype-export.json"'
        return response

    def has_add_permission(self, request):
        return False

    def has_delete_permission(self, request, obj=None):
        return request.user.is_superuser

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        qs = qs.annotate(num_infotypes=Count("zaaktypeinformatieobjecttypeconfig"))
        qs = qs.annotate(num_statustypes=Count("zaaktypestatustypeconfig"))
        qs = qs.annotate(num_resulttypes=Count("zaaktyperesultaattypeconfig"))
        qs = qs.annotate(
            num_doc_notify=Count(
                "zaaktypeinformatieobjecttypeconfig",
                filter=Q(
                    zaaktypeinformatieobjecttypeconfig__document_notification_enabled=True
                ),
            )
        )
        qs = qs.annotate(
            has_doc_notify=ExpressionWrapper(
                Q(num_doc_notify__gt=0), output_field=BooleanField()
            )
        )
        return qs

    def num_infotypes(self, obj=None):
        if not obj or not obj.pk:
            return "-"
        else:
            return getattr(obj, "num_infotypes", 0)

    num_infotypes.admin_order_field = "num_infotypes"

    def num_statustypes(self, obj=None):
        if not obj or not obj.pk:
            return "-"
        else:
            return getattr(obj, "num_statustypes", 0)

    num_statustypes.admin_order_field = "num_statustypes"

    def num_resulttypes(self, obj=None):
        if not obj or not obj.pk:
            return "-"
        else:
            return getattr(obj, "num_resulttypes", 0)

    num_resulttypes.admin_order_field = "num_resulttypes"

    def has_doc_notify(self, obj=None):
        if not obj or not obj.pk:
            return False
        else:
            return getattr(obj, "has_doc_notify", False)

    has_doc_notify.boolean = True
    has_doc_notify.admin_order_field = "has_doc_notify"

    @admin.action(description="Set selected Zaaktypes to notify on status changes")
    def mark_as_notify_status_changes(self, request, qs):
        count = qs.update(notify_status_changes=True)
        self.message_user(
            request,
            ngettext(
                "%d zaaktype was successfully set to notify on status changes.",
                "%d zaaktypes were successfully set to notify on status changes.",
                count,
            )
            % count,
            level=messages.SUCCESS,
        )

    @admin.action(description="Set selected Zaaktypes to not notify on status changes")
    def mark_as_not_notify_status_changes(self, request, qs):
        count = qs.update(notify_status_changes=False)
        self.message_user(
            request,
            ngettext(
                "%d zaaktype was successfully set to not notify on status changes.",
                "%d zaaktypes were successfully set to not notify on status changes.",
                count,
            )
            % count,
            level=messages.SUCCESS,
        )


@admin.register(UserCaseStatusNotification)
class UserCaseStatusNotificationAdmin(admin.ModelAdmin):
    raw_id_fields = ["user"]
    search_fields = [
        "user__first_name",
        "user__last_name",
        "user__email",
        "user__id",
        "case_uuid",
        "status_uuid",
    ]
    list_display = [
        "user",
        "case_uuid",
        "status_uuid",
        "created_on",
        "is_sent",
    ]
    list_filter = [
        "is_sent",
    ]

    def has_change_permission(self, request, obj=None):
        return False


@admin.register(UserCaseInfoObjectNotification)
class UserCaseInfoObjectNotificationAdmin(admin.ModelAdmin):
    raw_id_fields = ["user"]
    search_fields = [
        "user__first_name",
        "user__last_name",
        "user__email",
        "user__id",
        "case_uuid",
        "zaak_info_object_uuid",
    ]
    list_display = [
        "user",
        "case_uuid",
        "zaak_info_object_uuid",
        "created_on",
        "is_sent",
    ]
    list_filter = [
        "is_sent",
    ]

    def has_change_permission(self, request, obj=None):
        return False
